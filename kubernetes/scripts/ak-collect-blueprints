#!/usr/bin/env python3
"""
Generate Authentik blueprints from Kubernetes ingress resources with ak-*
labels/annotations. Updates files when drift is detected and exits non‑zero;
exits zero when no changes are required.
"""

import filecmp
import re
import shutil
import sys
import yaml
from pathlib import Path
from typing import Dict, List, Any
from jinja2 import Template

# Configuration constants
PORT_MAPPING = {
    "http": 80,
    "https": 443,
}

# Supported authentication types (templates are blueprint-templates/{type}.yaml.j2)
AUTH_TYPES = ["simple", "basic"]


def find_ingress_files(base_dir: Path) -> List[Path]:
    """Find all YAML files that might contain ingress resources."""
    candidates: set[Path] = set()
    for pattern in ("*.yaml", "*.yml"):
        for yaml_file in base_dir.rglob(pattern):
            # Skip generated outputs
            if "generated-blueprints" in yaml_file.parts:
                continue
            candidates.add(yaml_file)
    return sorted(candidates)


def parse_ingress_file(file_path: Path) -> List[Dict[str, Any]]:
    """Parse YAML file and return ingress resources with ak-simple or ak-basic annotation/label."""
    try:
        # Read file content first
        with open(file_path, "r") as f:
            content = f.read()

        # Quick check for ingress kind before parsing YAML
        if not re.search(r"kind:\s*Ingress", content, re.IGNORECASE):
            return []

        # Parse YAML only if it contains ingress resources
        docs = list(yaml.safe_load_all(content))

        ingresses = []
        for doc in docs:
            if not doc or doc.get("kind") != "Ingress":
                continue

            # Check for ak-simple or ak-basic label or annotation
            metadata = doc.get("metadata", {})
            labels = metadata.get("labels", {})
            annotations = metadata.get("annotations", {})

            has_simple = (
                labels.get("ak-simple") == "true"
                or annotations.get("ak-simple") == "true"
            )
            has_basic = (
                labels.get("ak-basic") == "true"
                or annotations.get("ak-basic") == "true"
            )

            if has_simple or has_basic:
                # Add auth_type to the document for template selection
                doc["_auth_type"] = "basic" if has_basic else "simple"
                ingresses.append(doc)

        return ingresses
    except Exception as e:
        print(f"Warning: Could not parse {file_path}: {e}", file=sys.stderr)
        return []


def extract_ingress_info(ingress: Dict[str, Any], file_path: Path) -> Dict[str, str]:
    """Extract app info from ingress resource."""
    metadata = ingress.get("metadata", {})
    spec = ingress.get("spec", {})

    # Get service name from directory structure
    service_name = None
    path_parts = file_path.parts
    for i, part in enumerate(path_parts):
        if part == "kubernetes" and i + 1 < len(path_parts):
            service_name = path_parts[i + 1]
            break

    if not service_name:
        raise ValueError(f"Could not determine service name from path: {file_path}")

    ingress_name = metadata.get("name", "")
    namespace = metadata.get("namespace", "default")

    # Get external host from first rule
    rules = spec.get("rules", [])
    if not rules:
        raise ValueError(f"No rules found in ingress {metadata.get('name')}")

    external_host = f"https://{rules[0].get('host', '')}"

    # Get service info from first path
    paths = rules[0].get("http", {}).get("paths", [])
    if not paths:
        raise ValueError(f"No paths found in ingress {metadata.get('name')}")

    backend = paths[0].get("backend", {}).get("service", {})
    k8s_service_name = backend.get("name", "")
    service_port = backend.get("port", {})

    # Handle both number and name port specifications
    if isinstance(service_port, dict):
        if "number" in service_port:
            port = service_port["number"]
        elif "name" in service_port:
            port_name = service_port["name"]
            if port_name not in PORT_MAPPING:
                raise ValueError(
                    f"Unknown port name '{port_name}' in ingress {metadata.get('name')} - add to PORT_MAPPING"
                )
            port = PORT_MAPPING[port_name]
        else:
            raise ValueError(
                f"Service port specification missing both 'number' and 'name' in ingress {metadata.get('name')}"
            )
    else:
        raise ValueError(
            f"Invalid service port specification in ingress {metadata.get('name')}: expected dict, got {type(service_port)}"
        )

    internal_host = f"http://{k8s_service_name}.{namespace}.svc.cluster.local:{port}"

    return {
        "service_name": service_name,
        "ingress_name": ingress_name,
        "app_name": service_name,  # Will be updated by resolve_app_names if needed
        "namespace": namespace,
        "external_host": external_host,
        "internal_host": internal_host,
        "auth_type": ingress["_auth_type"],
    }


def resolve_app_names(raw_app_infos: List[Dict[str, str]]) -> List[Dict[str, str]]:
    """Resolve final app names, adding ingress suffixes when there are conflicts."""
    # Group by service name
    service_groups = {}
    for app_info in raw_app_infos:
        service_name = app_info["service_name"]
        if service_name not in service_groups:
            service_groups[service_name] = []
        service_groups[service_name].append(app_info)

    # Update app names for services with multiple ingresses
    resolved_infos = []
    for service_name, infos in service_groups.items():
        if len(infos) == 1:
            # Single ingress - use service name
            infos[0]["app_name"] = service_name
            resolved_infos.extend(infos)
        else:
            # Multiple ingresses - add ingress name suffix
            for info in infos:
                ingress_suffix = (
                    info["ingress_name"]
                    .replace(f"{service_name}-", "")
                    .replace("-ingress", "")
                )
                info["app_name"] = f"{service_name}-{ingress_suffix}"
                resolved_infos.append(info)

    return resolved_infos


def generate_blueprint(template_content: str, app_info: Dict[str, str]) -> str:
    """Generate blueprint using Jinja2 template engine."""
    template = Template(template_content)
    return template.render(**app_info)


def generate_outpost_yaml(app_names: List[str], outpost_template: str) -> str:
    """Generate complete outpost YAML configuration using Jinja2 template."""
    # Sort app names for deterministic output
    sorted_app_names = sorted(app_names)

    template = Template(outpost_template)
    return template.render(app_names=sorted_app_names)


def update_kustomization_configmap(
    kustomization_file: Path, app_infos: List[Dict[str, str]]
) -> None:
    """Update kustomization.yaml with configMapGenerator section."""
    # Read the existing file
    with open(kustomization_file, "r") as f:
        lines = f.readlines()

    # Find the marker line
    marker_line = "# ak-collect-blueprints: auto-generated section below\n"
    try:
        marker_index = lines.index(marker_line)
    except ValueError:
        raise ValueError(
            f"Marker line not found in {kustomization_file}. Expected: {marker_line.strip()}"
        )

    # Keep everything up to and including the marker line
    new_lines = lines[: marker_index + 1]

    # Generate the configMapGenerator section
    new_lines.append("configMapGenerator:\n")
    new_lines.append("- name: authentik-blueprints\n")
    new_lines.append("  files:\n")

    # Add blueprint files
    for app_info in app_infos:
        new_lines.append(f"  - generated-blueprints/{app_info['app_name']}.yaml\n")

    # Add outpost file
    new_lines.append("  - generated-blueprints/outpost.yaml\n")
    new_lines.append("  options:\n")
    new_lines.append("    disableNameSuffixHash: true\n")

    # Write to temp file then move into place
    temp_file = kustomization_file.with_suffix(".tmp")
    with open(temp_file, "w") as f:
        f.writelines(new_lines)

    temp_file.replace(kustomization_file)


def collect_ingress_info(base_dir: Path) -> List[Dict[str, str]]:
    """Collect and process ingress information from all YAML files."""
    ingress_files = find_ingress_files(base_dir)

    raw_app_infos = []
    errors = []
    for file_path in ingress_files:
        ingresses = parse_ingress_file(file_path)
        for ingress in ingresses:
            try:
                app_info = extract_ingress_info(ingress, file_path)
                raw_app_infos.append(app_info)
            except ValueError as e:
                errors.append(str(e))
                print(f"Warning: {e}", file=sys.stderr)

    # Determine final app names based on service conflicts
    app_infos = resolve_app_names(raw_app_infos)

    # Sort and display found services
    sorted_app_infos = sorted(app_infos, key=lambda x: (x["auth_type"], x["app_name"]))

    print("Found services with authentik annotations:")
    for app_info in sorted_app_infos:
        auth_type = app_info["auth_type"]
        print(f"  ✓ ak-{auth_type}: {app_info['app_name']}")
    print()

    if not app_infos:
        print("No ingresses with ak-simple or ak-basic found")
        return []

    # Exit if any errors occurred during parsing
    if errors:
        print(
            f"ERROR: {len(errors)} errors occurred during parsing. Aborting.",
            file=sys.stderr,
        )
        sys.exit(1)

    return sorted_app_infos


def generate_blueprints_to_temp(
    templates: Dict[str, str],
    outpost_template: str,
    app_infos: List[Dict[str, str]],
    temp_dir: Path,
) -> None:
    """Generate all blueprints to temporary directory."""
    # Clean temporary directory
    for existing_file in temp_dir.glob("*.yaml"):
        existing_file.unlink()

    # Generate individual blueprints
    print("Generating blueprints...")
    for app_info in app_infos:
        auth_type = app_info["auth_type"]
        template_content = templates[auth_type]
        blueprint_content = generate_blueprint(template_content, app_info)
        blueprint_file = temp_dir / f"{app_info['app_name']}.yaml"

        with open(blueprint_file, "w") as f:
            f.write(blueprint_content)
            if not blueprint_content.endswith("\n"):
                f.write("\n")

        print(f"  ✓ {app_info['app_name']} ({auth_type})")

    # Generate outpost configuration
    app_names = [info["app_name"] for info in app_infos]
    outpost_content = generate_outpost_yaml(app_names, outpost_template)

    outpost_file = temp_dir / "outpost.yaml"
    with open(outpost_file, "w") as f:
        f.write(outpost_content)
        if not outpost_content.endswith("\n"):
            f.write("\n")

    print("  ✓ outpost (all providers)")
    print()


def directories_are_different(dir1: Path, dir2: Path) -> bool:
    """Compare two directories and return True if they are different."""
    if not dir1.exists() or not dir2.exists():
        return True

    # Get all files in both directories
    files1 = {f.relative_to(dir1) for f in dir1.rglob("*") if f.is_file()}
    files2 = {f.relative_to(dir2) for f in dir2.rglob("*") if f.is_file()}

    # Different file sets means directories are different
    if files1 != files2:
        return True

    # Compare each file
    for file_path in files1:
        if not filecmp.cmp(dir1 / file_path, dir2 / file_path, shallow=False):
            return True

    return False


def main():
    script_dir = Path(__file__).parent.resolve()
    base_dir = script_dir.parent
    authentik_dir = base_dir / "authentik"
    output_dir = authentik_dir / "generated-blueprints"

    # Load templates
    print("Loading blueprint templates...")
    template_contents = {}
    for auth_type in sorted(AUTH_TYPES):
        template_file = authentik_dir / "blueprint-templates" / f"{auth_type}.yaml.j2"
        if not template_file.exists():
            print(f"Template file not found: {template_file}", file=sys.stderr)
            sys.exit(1)

        with open(template_file, "r") as f:
            template_contents[auth_type] = f.read()
        print(f"  ✓ {auth_type} template: {template_file.name}")

    # Load outpost template
    outpost_template_file = authentik_dir / "blueprint-templates" / "outpost.yaml.j2"
    if not outpost_template_file.exists():
        print(f"Outpost template not found: {outpost_template_file}", file=sys.stderr)
        sys.exit(1)

    with open(outpost_template_file, "r") as f:
        outpost_template = f.read()
    print(f"  ✓ outpost template: {outpost_template_file.name}")
    print()

    # Collect ingress information
    app_infos = collect_ingress_info(base_dir)
    if not app_infos:
        return

    # Create temporary directory (clean it first if it exists)
    temp_dir = output_dir.with_suffix(".tmp")
    if temp_dir.exists():
        shutil.rmtree(temp_dir)
    temp_dir.mkdir(parents=True, exist_ok=True)

    try:
        # Generate blueprints to temporary directory
        generate_blueprints_to_temp(
            template_contents, outpost_template, app_infos, temp_dir
        )

        # Compare generated blueprints directory to existing one
        would_change_dir = directories_are_different(output_dir, temp_dir)

        # Capture current kustomization content, update it, and detect changes
        kustomization_file = base_dir / "authentik" / "kustomization.yaml"
        try:
            before_kustom = kustomization_file.read_text()
        except FileNotFoundError:
            before_kustom = ""
        update_kustomization_configmap(kustomization_file, app_infos)
        after_kustom = kustomization_file.read_text()
        kustom_changed = before_kustom != after_kustom

        # If anything changed, replace the real blueprints dir and exit non-zero
        if would_change_dir:
            if output_dir.exists():
                shutil.rmtree(output_dir)
            shutil.move(temp_dir, output_dir)
        else:
            # No change in blueprints; remove temp
            shutil.rmtree(temp_dir)

        # Summary
        if would_change_dir or kustom_changed:
            print("Blueprint generation complete!")
            print(
                f"  • Generated: {len(app_infos)} service blueprints + 1 outpost config"
            )
            print(f"  • Updated: {kustomization_file.name}")
            print(f"  • Output: {output_dir.relative_to(base_dir)}")
            sys.exit(1)
        else:
            print("Blueprint files are up to date")
            return

    except Exception as e:
        print(f"ERROR: Failed to generate blueprints: {e}", file=sys.stderr)
        print(f"Temporary files left in {temp_dir} for debugging", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
