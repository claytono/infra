#!/usr/bin/env python3
"""
Generate Authentik blueprints from Kubernetes ingress resources with ak-*
labels/annotations. Updates files when drift is detected and exits nonâ€‘zero;
exits zero when no changes are required.
"""

import filecmp
import json
import os
import base64
import secrets
import subprocess
import re
import shutil
import sys
import yaml
from pathlib import Path
from typing import Dict, List, Any
from jinja2 import Template

# Configuration constants
PORT_MAPPING = {
    "http": 80,
    "https": 443,
}

# 1Password vault for OIDC client credentials
OP_VAULT = "Kubernetes"

# Supported authentication types (templates are blueprint-templates/{type}.yaml.j2)
# We no longer generate per-app OIDC blueprints; OIDC is handled via consolidated ExternalSecret
AUTH_TYPES = ["simple", "basic"]

# Unified generated output directory (blueprints + externalsecret)
GENERATED_DIR_NAME = "generated"


def find_ingress_files(base_dir: Path) -> List[Path]:
    """Find all YAML files that might contain ingress resources."""
    candidates: set[Path] = set()
    for pattern in ("*.yaml", "*.yml"):
        for yaml_file in base_dir.rglob(pattern):
            # Skip generated outputs
            # Skip generated outputs
            if "generated" in yaml_file.parts:
                continue
            candidates.add(yaml_file)
    return sorted(candidates)


def parse_ingress_file(file_path: Path) -> List[Dict[str, Any]]:
    """Parse YAML file and return ingress resources with ak-type markers only."""
    try:
        # Read file content first
        with open(file_path, "r") as f:
            content = f.read()

        # Quick check for ingress kind before parsing YAML
        if not re.search(r"kind:\s*Ingress", content, re.IGNORECASE):
            return []

        # Parse YAML only if it contains ingress resources
        docs = list(yaml.safe_load_all(content))

        ingresses = []
        for doc in docs:
            if not doc or doc.get("kind") != "Ingress":
                continue

            # Check for ak-type label/annotation (unified selector)
            metadata = doc.get("metadata", {}) or {}
            labels = metadata.get("labels") or {}
            annotations = metadata.get("annotations") or {}

            # Unified key
            type_val = labels.get("ak-type") or annotations.get("ak-type")
            if type_val:
                norm = type_val.strip().lower()
                # Support only 'basic-auth' (not 'basic'), plus 'simple' and 'oidc'
                if norm in ("simple", "basic-auth", "oidc"):
                    if norm == "basic-auth":
                        # Map to internal template name
                        norm = "basic"
                    doc["_auth_type"] = norm
                    ingresses.append(doc)

        return ingresses
    except Exception as e:
        print(f"Warning: Could not parse {file_path}: {e}", file=sys.stderr)
        return []


def extract_ingress_info(ingress: Dict[str, Any], file_path: Path) -> Dict[str, str]:
    """Extract app info from ingress resource."""
    metadata = ingress.get("metadata", {})
    spec = ingress.get("spec", {})

    # Get service name from directory structure
    service_name = None
    path_parts = file_path.parts
    for i, part in enumerate(path_parts):
        if part == "kubernetes" and i + 1 < len(path_parts):
            service_name = path_parts[i + 1]
            break

    if not service_name:
        raise ValueError(f"Could not determine service name from path: {file_path}")

    ingress_name = metadata.get("name", "")
    namespace = metadata.get("namespace", "default")

    # Get external host from first rule
    rules = spec.get("rules", [])
    if not rules:
        raise ValueError(f"No rules found in ingress {metadata.get('name')}")

    external_host = f"https://{rules[0].get('host', '')}"

    # Get service info from first path
    paths = rules[0].get("http", {}).get("paths", [])
    if not paths:
        raise ValueError(f"No paths found in ingress {metadata.get('name')}")

    backend = paths[0].get("backend", {}).get("service", {})
    k8s_service_name = backend.get("name", "")
    service_port = backend.get("port", {})

    # Handle both number and name port specifications
    if isinstance(service_port, dict):
        if "number" in service_port:
            port = service_port["number"]
        elif "name" in service_port:
            port_name = service_port["name"]
            if port_name not in PORT_MAPPING:
                raise ValueError(
                    f"Unknown port name '{port_name}' in ingress {metadata.get('name')} - add to PORT_MAPPING"
                )
            port = PORT_MAPPING[port_name]
        else:
            raise ValueError(
                f"Service port specification missing both 'number' and 'name' in ingress {metadata.get('name')}"
            )
    else:
        raise ValueError(
            f"Invalid service port specification in ingress {metadata.get('name')}: expected dict, got {type(service_port)}"
        )

    internal_host = f"http://{k8s_service_name}.{namespace}.svc.cluster.local:{port}"

    # Optional path exclusions from annotation "ak-path-exclude"
    annotations = metadata.get("annotations", {})
    raw_excludes = annotations.get("ak-path-exclude", "")

    exclude_patterns: List[str] = []
    if raw_excludes:
        # Split by newlines or commas to support multi-line annotation values
        for piece in re.split(r"[\n,]", str(raw_excludes)):
            p = piece.strip()
            if not p:
                continue
            # If pattern looks like a full URL (with optional leading ^), leave as-is
            if re.match(r"^\^?https?://", p):
                # Ensure patterns are anchored at start
                if not p.startswith("^"):
                    p = f"^{p}"
                exclude_patterns.append(p)
                continue
            # Treat as a path-based regex; ensure it starts with '/'
            if not p.startswith("/"):
                p = "/" + p
            # Anchor at the service external host
            exclude_patterns.append(f"^{external_host}{p}")

    info: Dict[str, Any] = {
        "service_name": service_name,
        "ingress_name": ingress_name,
        "app_name": service_name,  # Will be updated by resolve_app_names if needed
        "namespace": namespace,
        "external_host": external_host,
        "internal_host": internal_host,
        "auth_type": ingress["_auth_type"],
        "skip_path_regex": "\n".join(exclude_patterns),
    }

    # If OIDC, require callback path annotation "ak-oidc-callback"
    if info["auth_type"] == "oidc":
        cb = annotations.get("ak-oidc-callback")
        if not isinstance(cb, str) or not cb.strip():
            raise ValueError(
                f"Ingress '{metadata.get('name')}' requires annotation 'ak-oidc-callback' for OIDC"
            )
        cb = cb.strip()
        if not cb.startswith("/"):
            cb = "/" + cb
        info["oidc_callback_path"] = cb

    return info


def resolve_app_names(raw_app_infos: List[Dict[str, str]]) -> List[Dict[str, str]]:
    """Resolve final app names, adding ingress suffixes when there are conflicts."""
    # Group by service name
    service_groups = {}
    for app_info in raw_app_infos:
        service_name = app_info["service_name"]
        if service_name not in service_groups:
            service_groups[service_name] = []
        service_groups[service_name].append(app_info)

    # Update app names for services with multiple ingresses
    resolved_infos = []
    for service_name, infos in service_groups.items():
        if len(infos) == 1:
            # Single ingress - use service name
            infos[0]["app_name"] = service_name
            resolved_infos.extend(infos)
        else:
            # Multiple ingresses - add ingress name suffix
            for info in infos:
                ingress_suffix = (
                    info["ingress_name"]
                    .replace(f"{service_name}-", "")
                    .replace("-ingress", "")
                )
                info["app_name"] = f"{service_name}-{ingress_suffix}"
                resolved_infos.append(info)

    return resolved_infos


def generate_blueprint(template_content: str, app_info: Dict[str, str]) -> str:
    """Generate blueprint using Jinja2 template engine."""
    template = Template(template_content)
    return template.render(**app_info)


def generate_outpost_yaml(app_names: List[str], outpost_template: str) -> str:
    """Generate complete outpost YAML configuration using Jinja2 template."""
    # Sort app names for deterministic output
    sorted_app_names = sorted(app_names)

    template = Template(outpost_template)
    return template.render(app_names=sorted_app_names)


def update_kustomization_configmap(
    kustomization_file: Path, app_infos: List[Dict[str, str]]
) -> None:
    """Update kustomization.yaml with configMapGenerator section."""
    # Read the existing file
    with open(kustomization_file, "r") as f:
        lines = f.readlines()

    # Find the marker line
    marker_line = "# ak-collect-blueprints: auto-generated section below\n"
    try:
        marker_index = lines.index(marker_line)
    except ValueError:
        raise ValueError(
            f"Marker line not found in {kustomization_file}. Expected: {marker_line.strip()}"
        )

    # Keep everything up to and including the marker line
    new_lines = lines[: marker_index + 1]

    # Generate the configMapGenerator section
    new_lines.append("configMapGenerator:\n")
    new_lines.append("- name: authentik-blueprints\n")
    new_lines.append("  files:\n")

    # Add blueprint files (exclude OIDC, which is handled via consolidated ExternalSecret)
    for app_info in app_infos:
        if app_info.get("auth_type") == "oidc":
            continue
        new_lines.append(f"  - {GENERATED_DIR_NAME}/{app_info['app_name']}.yaml\n")

    # Add outpost file
    new_lines.append(f"  - {GENERATED_DIR_NAME}/outpost.yaml\n")
    new_lines.append("  options:\n")
    new_lines.append("    disableNameSuffixHash: true\n")

    # Write to temp file then move into place
    temp_file = kustomization_file.with_suffix(".tmp")
    with open(temp_file, "w") as f:
        f.writelines(new_lines)

    temp_file.replace(kustomization_file)


def collect_ingress_info(base_dir: Path) -> List[Dict[str, str]]:
    """Collect and process ingress information from all YAML files."""
    ingress_files = find_ingress_files(base_dir)

    raw_app_infos = []
    errors = []
    for file_path in ingress_files:
        ingresses = parse_ingress_file(file_path)
        for ingress in ingresses:
            try:
                app_info = extract_ingress_info(ingress, file_path)
                raw_app_infos.append(app_info)
            except ValueError as e:
                errors.append(str(e))
                print(f"Warning: {e}", file=sys.stderr)

    # Determine final app names based on service conflicts
    app_infos = resolve_app_names(raw_app_infos)

    # Sort and display found services
    sorted_app_infos = sorted(app_infos, key=lambda x: (x["auth_type"], x["app_name"]))

    print("Found services with ak-type annotations:")
    for app_info in sorted_app_infos:
        auth_type = app_info["auth_type"]
        print(f"  âœ“ ak-{auth_type}: {app_info['app_name']}")
    print()

    if not app_infos:
        print("No ingresses with ak-type found")
        return []

    # Exit if any errors occurred during parsing
    if errors:
        print(
            f"ERROR: {len(errors)} errors occurred during parsing. Aborting.",
            file=sys.stderr,
        )
        sys.exit(1)

    return sorted_app_infos


def _op_available() -> bool:
    return shutil.which("op") is not None


def _op_run(
    args: List[str],
    *,
    input: str | None = None,
    check: bool = True,
    capture_output: bool = False,
) -> subprocess.CompletedProcess:
    """Run an op CLI command with safe defaults (stdin for sensitive data)."""
    cmd = ["op", *args]
    return subprocess.run(
        cmd,
        check=check,
        input=input,
        text=True,
        capture_output=capture_output,
    )


def _op_item_apply_template(
    action: str, payload: str, title: str | None = None, *, vault: str = OP_VAULT
) -> None:
    """Apply a Jinja-rendered template by piping it to op via stdin.

    Uses --template /dev/stdin to avoid temporary files.
    """
    args: List[str] = ["item", action]
    if action == "edit" and title:
        args.append(title)
    # Read template from STDIN to avoid temp files
    args.extend(["--vault", vault, "--template", "/dev/stdin"])
    _op_run(args, input=payload)


def _should_skip_op() -> bool:
    """Return True when running in CI/lint environment or explicitly requested to skip."""
    env_true = {"1", "true", "yes", "on"}
    return (
        os.environ.get("AK_SKIP_OP", "").lower() in env_true
        or os.environ.get("GITHUB_ACTIONS", "").lower() in env_true
        or os.environ.get("CI", "").lower() in env_true
    )


def _generate_oidc_client_secret_b64() -> str:
    """Generate a strong client secret: 32 random bytes, base64-encoded."""
    rand = secrets.token_bytes(32)
    return base64.b64encode(rand).decode("ascii")


def _get_blueprint_template_path(name: str) -> Path:
    """Return path to a template under authentik/blueprint-templates."""
    script_dir = Path(__file__).parent.resolve()
    return script_dir.parent / "authentik" / "blueprint-templates" / name


# Note: legacy template-based payload rendering removed; we update items via
# direct JSON edits through _ensure_item_fields and _op_item_apply_template.


def _ensure_item_fields(
    item: Dict[str, Any], client_id: str, client_secret: str
) -> Dict[str, Any]:
    """Ensure notesPlain, client-id, and client-secret fields exist with correct types/values."""
    fields = item.get("fields") or []
    by_label = {f.get("label"): f for f in fields if isinstance(f, dict)}

    # notesPlain
    note_val = "Generated and managed by ak-collect-blueprints (OIDC bootstrap). Do not edit manually."
    if "notesPlain" in by_label:
        by_label["notesPlain"]["value"] = note_val
    else:
        fields.append(
            {
                "id": "notesPlain",
                "type": "STRING",
                "purpose": "NOTES",
                "label": "notesPlain",
                "value": note_val,
            }
        )

    # client-id
    if "client-id" in by_label:
        by_label["client-id"]["type"] = "STRING"
        by_label["client-id"]["value"] = client_id
    else:
        fields.append(
            {
                "id": "client-id",
                "type": "STRING",
                "label": "client-id",
                "value": client_id,
            }
        )

    # client-secret
    if "client-secret" in by_label:
        by_label["client-secret"]["type"] = "CONCEALED"
        by_label["client-secret"]["value"] = client_secret
    else:
        fields.append(
            {
                "id": "client-secret",
                "type": "CONCEALED",
                "label": "client-secret",
                "value": client_secret,
            }
        )

    item["fields"] = fields
    return item


def ensure_1password_oidc_items(app_infos: List[Dict[str, str]]) -> None:
    """Ensure each OIDC app has a 1Password 'password' item <app>-oidc with typed client-id and client-secret."""
    oidc_apps = [i for i in app_infos if i.get("auth_type") == "oidc"]
    if not oidc_apps:
        return

    # Skip in CI/lint contexts
    if _should_skip_op():
        print("Skipping 1Password item management (CI/lint environment)")
        return

    if not _op_available():
        print("FATAL: 1Password 'op' CLI not found in PATH.")
        print("Install and sign in to 'op' CLI before running ak-collect-blueprints.")
        sys.exit(1)

    for info in oidc_apps:
        app = info["app_name"]
        title = f"{app}-oidc"
        client_id = app

        # Try to read existing item
        result = _op_run(
            ["item", "get", title, "--vault", OP_VAULT, "--format", "json"],
            check=False,
            capture_output=True,
        )
        if result.returncode == 0:
            data = json.loads(result.stdout or "{}")
            fields = {f.get("label"): f for f in data.get("fields", [])}
            needs_update = False
            # Ensure client-id
            if not fields.get("client-id") or not fields["client-id"].get("value"):
                needs_update = True
            # Ensure client-secret
            if not fields.get("client-secret") or not fields["client-secret"].get(
                "value"
            ):
                needs_update = True

            if needs_update:
                secret_val = _generate_oidc_client_secret_b64()
                updated = _ensure_item_fields(
                    data, client_id=client_id, client_secret=secret_val
                )
                _op_item_apply_template(
                    "edit", payload=json.dumps(updated), title=title
                )
                print(f"  â€¢ Updated 1Password item: {title}")
            else:
                print(f"  â€¢ 1Password item up-to-date: {title}")
        else:
            # Create base password item, then update fields via full JSON edit
            _op_run(
                [
                    "item",
                    "create",
                    "--category",
                    "password",
                    "--title",
                    title,
                    "--vault",
                    OP_VAULT,
                ]
            )
            # Fetch the created item
            created = _op_run(
                ["item", "get", title, "--vault", OP_VAULT, "--format", "json"],
                capture_output=True,
            )
            item_json = json.loads(created.stdout or "{}")
            secret_val = _generate_oidc_client_secret_b64()
            updated = _ensure_item_fields(
                item_json, client_id=client_id, client_secret=secret_val
            )
            _op_item_apply_template("edit", payload=json.dumps(updated), title=title)
            print(f"  â€¢ Created 1Password item: {title}")


def render_oidc_blueprints_externalsecret(
    authentik_dir: Path, app_infos: List[Dict[str, str]]
) -> str:
    """Render a single ExternalSecret via Jinja template for all OIDC apps."""
    template_path = _get_blueprint_template_path(
        "externalsecret-oidc-blueprints.yaml.j2"
    )
    with open(template_path, "r") as f:
        template_content = f.read()

    oidc_apps = sorted(
        [i for i in app_infos if i.get("auth_type") == "oidc"],
        key=lambda x: x["app_name"],
    )
    template = Template(template_content)
    return template.render(oidc_apps=oidc_apps)


def update_oidc_blueprints_externalsecret_file(
    authentik_dir: Path, app_infos: List[Dict[str, str]]
) -> bool:
    """Create/update authentik/generated/externalsecret-oidc-blueprints.yaml. Returns True if changed."""
    file_path = (
        authentik_dir / GENERATED_DIR_NAME / "externalsecret-oidc-blueprints.yaml"
    )
    new_content = render_oidc_blueprints_externalsecret(authentik_dir, app_infos)
    try:
        old_content = file_path.read_text()
    except FileNotFoundError:
        # Ensure directory exists on first write
        file_path.parent.mkdir(parents=True, exist_ok=True)
        old_content = ""

    # Normalize newlines for comparison
    if not new_content.endswith("\n"):
        new_content = new_content + "\n"

    if old_content != new_content:
        _write_text_ensure_newline(file_path, new_content)
        print(f"  â€¢ Updated: {file_path.relative_to(authentik_dir.parent)}")
        return True
    return False


def _write_text_ensure_newline(path: Path, content: str) -> None:
    with open(path, "w") as f:
        f.write(content)
        if not content.endswith("\n"):
            f.write("\n")


def generate_blueprints_to_temp(
    templates: Dict[str, str],
    outpost_template: str,
    app_infos: List[Dict[str, str]],
    temp_dir: Path,
    authentik_dir: Path,
) -> None:
    """Generate all blueprints to temporary directory."""
    # Clean temp dir
    for existing_file in temp_dir.glob("*.yaml"):
        existing_file.unlink()

    # Generate individual blueprints (non-OIDC)
    print("Generating blueprints...")
    for app_info in app_infos:
        if app_info["auth_type"] == "oidc":
            continue
        content = generate_blueprint(templates[app_info["auth_type"]], app_info)
        _write_text_ensure_newline(temp_dir / f"{app_info['app_name']}.yaml", content)
        print(f"  âœ“ {app_info['app_name']} ({app_info['auth_type']})")

    # Generate outpost config (providers for non-OIDC apps)
    app_names = [i["app_name"] for i in app_infos if i.get("auth_type") != "oidc"]
    outpost_content = generate_outpost_yaml(app_names, outpost_template)
    _write_text_ensure_newline(temp_dir / "outpost.yaml", outpost_content)
    print("  âœ“ outpost (all providers)")

    # Generate consolidated OIDC ExternalSecret
    es_content = render_oidc_blueprints_externalsecret(authentik_dir, app_infos)
    _write_text_ensure_newline(
        temp_dir / "externalsecret-oidc-blueprints.yaml", es_content
    )
    print("  âœ“ externalsecret-oidc-blueprints (all OIDC apps)")
    print()


def directories_are_different(dir1: Path, dir2: Path) -> bool:
    """Compare two directories and return True if they are different."""
    if not dir1.exists() or not dir2.exists():
        return True

    # Get all files in both directories
    files1 = {f.relative_to(dir1) for f in dir1.rglob("*") if f.is_file()}
    files2 = {f.relative_to(dir2) for f in dir2.rglob("*") if f.is_file()}

    # Different file sets means directories are different
    if files1 != files2:
        return True

    # Compare each file
    for file_path in files1:
        if not filecmp.cmp(dir1 / file_path, dir2 / file_path, shallow=False):
            return True

    return False


def main():
    script_dir = Path(__file__).parent.resolve()
    base_dir = script_dir.parent
    authentik_dir = base_dir / "authentik"
    output_dir = authentik_dir / GENERATED_DIR_NAME

    # Load templates
    print("Loading blueprint templates...")
    template_contents = {}
    for auth_type in sorted(AUTH_TYPES):
        template_file = _get_blueprint_template_path(f"{auth_type}.yaml.j2")
        if not template_file.exists():
            print(f"Template file not found: {template_file}", file=sys.stderr)
            sys.exit(1)

        with open(template_file, "r") as f:
            template_contents[auth_type] = f.read()
        print(f"  âœ“ {auth_type} template: {template_file.name}")

    # Load outpost template
    outpost_template_file = _get_blueprint_template_path("outpost.yaml.j2")
    if not outpost_template_file.exists():
        print(f"Outpost template not found: {outpost_template_file}", file=sys.stderr)
        sys.exit(1)

    with open(outpost_template_file, "r") as f:
        outpost_template = f.read()
    print(f"  âœ“ outpost template: {outpost_template_file.name}")
    print()

    # Collect ingress information
    app_infos = collect_ingress_info(base_dir)
    if not app_infos:
        return

    # Create temporary directory (clean it first if it exists)
    temp_dir = output_dir.with_suffix(".tmp")
    if temp_dir.exists():
        shutil.rmtree(temp_dir)
    temp_dir.mkdir(parents=True, exist_ok=True)

    try:
        # Generate blueprints to temporary directory
        generate_blueprints_to_temp(
            template_contents, outpost_template, app_infos, temp_dir, authentik_dir
        )

        # Compare generated blueprints directory to existing one
        would_change_dir = directories_are_different(output_dir, temp_dir)

        # Capture current kustomization content, update it, and detect changes
        kustomization_file = base_dir / "authentik" / "kustomization.yaml"
        try:
            before_kustom = kustomization_file.read_text()
        except FileNotFoundError:
            before_kustom = ""
        update_kustomization_configmap(kustomization_file, app_infos)
        after_kustom = kustomization_file.read_text()
        kustom_changed = before_kustom != after_kustom

        # If anything changed, replace the real blueprints dir and exit non-zero
        if would_change_dir:
            if output_dir.exists():
                shutil.rmtree(output_dir)
            shutil.move(temp_dir, output_dir)
        else:
            # No change in blueprints; remove temp
            shutil.rmtree(temp_dir)

        # Manage 1Password items and consolidated OIDC ExternalSecret
        # Ensure 1Password items exist (fatal if op not available)
        ensure_1password_oidc_items(app_infos)

        es_changed = update_oidc_blueprints_externalsecret_file(
            authentik_dir, app_infos
        )

        # Summary
        if would_change_dir or kustom_changed or es_changed:
            print("Blueprint generation complete!")
            print(
                f"  â€¢ Generated: {len(app_infos)} service blueprints + 1 outpost config"
            )
            print(
                f"  â€¢ Updated: {kustomization_file.name}{' + externalsecret-oidc-blueprints.yaml' if es_changed else ''}"
            )
            print(f"  â€¢ Output: {output_dir.relative_to(base_dir)}")
            sys.exit(1)
        else:
            print("Blueprint files are up to date")
            return

    except Exception as e:
        print(f"ERROR: Failed to generate blueprints: {e}", file=sys.stderr)
        print(f"Temporary files left in {temp_dir} for debugging", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
