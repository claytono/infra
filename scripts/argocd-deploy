#!/usr/bin/env python3
"""
argocd-deploy.py ‚Äî Deploy Argo CD applications with per-app retries

This script deploys Argo CD applications to a specified target revision and tracks
success/failure status for each application individually.

HOW IT WORKS:
1. For each application: ensure it exists, sync to target revision (optionally with --prune), then wait for Healthy
2. Tracks which applications succeed vs fail during deployment
3. Optionally comments deployment results on GitHub PRs
4. Exits with error code if any deployments fail
5. Implements retry logic with **linear** backoff

GITHUB ACTIONS INTEGRATION:
The script comments deployment results on PRs when --comment-pr is provided.

EXAMPLES:
./argocd-deploy.py --apps "app1 app2" --target-revision "main"
./argocd-deploy.py --apps "webapp" --target-revision "feature-branch" --comment-pr 123

Usage: ./argocd-deploy.py --apps "app1 app2" --target-revision "branch-name" [--comment-pr PR_NUMBER]
"""

import argparse
import os
import subprocess
import sys
import time
from typing import List, Optional


class DeploymentError(Exception):
    """Custom exception for deployment failures"""
    pass


class ArgoCDDeployer:
    """ArgoCD deployment manager with retry logic and PR commenting"""

    def __init__(self, apps: List[str], target_revision: str, pr_number: Optional[str] = None,
                 action_run_url: Optional[str] = None, sync_timeout: int = 300, max_retries: int = 3):
        self.apps = apps
        self.target_revision = target_revision
        self.pr_number = pr_number
        self.action_run_url = action_run_url
        self.sync_timeout = sync_timeout
        self.max_retries = max_retries

    def run_command(self, cmd: List[str], capture_output: bool = True) -> subprocess.CompletedProcess:
        """Run a command and return the result"""
        try:
            result = subprocess.run(cmd, capture_output=capture_output, text=True, check=False)
            return result
        except Exception as e:
            raise DeploymentError(f"Failed to run command {' '.join(cmd)}: {e}")

    def ensure_app_exists(self, app: str) -> None:
        """Ensure an ArgoCD application exists, create if it doesn't"""
        print(f"Checking if {app} exists in ArgoCD...")

        # Check if app exists
        result = self.run_command(['argocd', 'app', 'get', app])

        if result.returncode != 0:
            print(f"Application {app} does not exist, creating it...")
            manifest_path = f"kubernetes/argocd-apps/{app}.yaml"

            if not os.path.exists(manifest_path):
                raise DeploymentError(f"Manifest file {manifest_path} not found for app {app}")

            result = self.run_command(['argocd', 'app', 'create', '--file', manifest_path])
            if result.returncode != 0:
                raise DeploymentError(f"Failed to create application {app}: {result.stderr}")

            print(f"‚úÖ Created application {app}")
        else:
            print(f"‚úÖ Application {app} already exists")

    def sync_app_to_revision(self, app: str) -> None:
        """Sync a single application to the target revision"""
        print(f"Syncing {app} to revision {self.target_revision} (with pruning)")

        cmd = ['argocd', 'app', 'sync', app,
               '--revision', self.target_revision,
               '--prune',
               '--timeout', str(self.sync_timeout)]

        result = self.run_command(cmd, capture_output=False)
        if result.returncode != 0:
            raise DeploymentError(f"Failed to sync {app} to {self.target_revision} (see sync output above)")

        print(f"‚úÖ Successfully synced {app} to {self.target_revision}")

    def wait_for_app(self, app: str) -> None:
        """Wait for an application to reach healthy status"""
        print(f"Waiting for {app} to become healthy...")

        cmd = ['argocd', 'app', 'wait', app, '--timeout', str(self.sync_timeout)]

        result = self.run_command(cmd, capture_output=False)
        if result.returncode != 0:
            raise DeploymentError(f"Application {app} failed to reach healthy status (see wait output above)")

        print(f"‚úÖ Application {app} is healthy")

    def deploy_single_app(self, app: str) -> bool:
        """Deploy a single application and return success status"""
        try:
            print(f"\n--- Deploying {app} ---")

            self.ensure_app_exists(app)
            self.sync_app_to_revision(app)
            self.wait_for_app(app)

            print(f"‚úÖ Successfully deployed {app}")
            return True

        except DeploymentError as e:
            print(f"‚ùå Failed to deploy {app}: {e}")
            return False

    def deploy_app_with_retries(self, app: str) -> bool:
        """Deploy a single app with retry logic"""
        for attempt in range(1, self.max_retries + 1):
            print(f"\n--- Deploying {app} (attempt {attempt}/{self.max_retries}) ---")

            if self.deploy_single_app(app):
                if attempt > 1:
                    print(f"‚úÖ {app} succeeded on attempt {attempt}/{self.max_retries}")
                return True
            else:
                if attempt < self.max_retries:
                    delay = attempt * 10  # 10s, 20s, 30s delays
                    print(f"‚ùå {app} failed (attempt {attempt}/{self.max_retries}). Retrying in {delay}s...")
                    time.sleep(delay)
                else:
                    print(f"‚ùå {app} failed after {self.max_retries} attempts")

        return False

    def comment_pr(self, message: str, is_failure: bool = False) -> None:
        """Comment on a PR with deployment results"""
        if not self.pr_number:
            print(f"PR Comment: {message}")
            return

        # Add action run link for failures
        if is_failure and self.action_run_url:
            message = f"{message}\n\n[View action run details]({self.action_run_url})"

        cmd = ['gh', 'pr', 'comment', self.pr_number, '--body', message]
        result = self.run_command(cmd)

        if result.returncode != 0:
            print(f"Warning: Failed to comment on PR: {result.stderr}")

    def deploy(self) -> None:
        """Deploy all apps with per-app retry logic"""
        print(f"Starting deployment of apps: {' '.join(self.apps)}")
        print(f"Target revision: {self.target_revision}")

        successful_apps = []
        failed_apps = []

        # Deploy each app individually with retries
        for app in self.apps:
            if self.deploy_app_with_retries(app):
                successful_apps.append(app)
            else:
                failed_apps.append(app)

        # Determine overall success and create message
        if failed_apps:
            if successful_apps:
                message = f"‚ùå Partial deployment failure: **{', '.join(failed_apps)}** failed, **{', '.join(successful_apps)}** succeeded"
            else:
                message = f"‚ùå All applications failed: **{', '.join(failed_apps)}**"
            is_failure = True
        else:
            message = f"üöÄ Successfully deployed **{', '.join(successful_apps)}** to `{self.target_revision}`"
            is_failure = False

        # Comment on the final result
        self.comment_pr(message, is_failure=is_failure)

        # Print summary
        print(f"\nDeployment Summary:")
        print(f"  Total: {len(self.apps)}")
        print(f"  Successful: {len(successful_apps)} - {', '.join(successful_apps) if successful_apps else 'None'}")
        print(f"  Failed: {len(failed_apps)} - {', '.join(failed_apps) if failed_apps else 'None'}")

        # Exit with error if any apps failed
        if failed_apps:
            sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Deploy ArgoCD applications to specified target revision",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )

    parser.add_argument('--apps', required=True,
                       help='Space-separated list of application names')
    parser.add_argument('--target-revision', required=True,
                       help='Target revision (branch/tag/commit)')
    parser.add_argument('--comment-pr',
                       help='Comment results on PR')
    parser.add_argument('--sync-timeout', type=int, default=300,
                       help='Sync timeout in seconds (default: 300)')
    parser.add_argument('--action-run-url',
                       help='GitHub Action run URL for failure comments')
    parser.add_argument('--max-retries', type=int, default=3,
                       help='Maximum retry attempts (default: 3)')

    args = parser.parse_args()

    # Parse apps from space-separated string (dedupe, preserve order)
    seen = set()
    apps = [a for a in args.apps.split() if not (a in seen or seen.add(a))]

    if not apps:
        print("Error: No applications provided")
        sys.exit(1)

    # Validate token for gh if PR commenting is requested (accept GH_TOKEN or GITHUB_TOKEN)
    if args.comment_pr:
        token = os.environ.get('GH_TOKEN') or os.environ.get('GITHUB_TOKEN')
        if not token:
            print("Error: GH_TOKEN or GITHUB_TOKEN required for PR commenting")
            sys.exit(1)
        # Ensure gh sees GH_TOKEN
        os.environ.setdefault('GH_TOKEN', token)

    deployer = ArgoCDDeployer(
        apps=apps,
        target_revision=args.target_revision,
        pr_number=args.comment_pr,
        action_run_url=args.action_run_url,
        sync_timeout=args.sync_timeout,
        max_retries=args.max_retries
    )

    deployer.deploy()


if __name__ == '__main__':
    main()
