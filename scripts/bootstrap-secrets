#!/bin/bash

set -eu -o pipefail

BASEDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$BASEDIR")"
VAULT="infra"

cd "$REPO_ROOT"

usage() {
  cat <<EOF
Usage: $(basename "$0") [OPTIONS] [TARGETS...]

Bootstrap secrets from 1Password for local development and cluster setup.

OPTIONS:
  --apply     Apply changes (default is diff/dry-run mode)
  -h, --help  Show this help message

TARGETS (run all if none specified):
  ansible     Ansible vault password
  direnv      Environment secrets for .envrc (.secrets file)
  esphome     ESPHome secrets.yaml
  kubernetes  Kubernetes namespaces and secrets (1password, external-secrets)

EXAMPLES:
  $(basename "$0")                    # Diff all targets
  $(basename "$0") --apply            # Apply all targets
  $(basename "$0") esphome            # Diff ESPHome only
  $(basename "$0") --apply esphome    # Apply ESPHome only
  $(basename "$0") ansible esphome    # Diff ansible and esphome
EOF
}

# Retrieve and validate required secrets from 1Password
# Only retrieves secrets needed for the specified targets
get_secrets() {
  local targets=("$@")
  local secrets_list=()

  # Build list of secrets needed based on targets
  for target in "${targets[@]}"; do
    case "$target" in
      ansible)
        secrets_list+=("ANSIBLE_VAULT_PASS:item get ansible-vault-password --fields password")
        ;;
      kubernetes)
        secrets_list+=("OP_CREDENTIALS:document get 1password-credentials.json")
        secrets_list+=("EXTERNAL_SECRETS_TOKEN:document get external-secrets-token")
        ;;
    esac
  done

  # ESPHome uses op inject directly, no secrets to fetch here

  if [[ ${#secrets_list[@]} -eq 0 ]]; then
    return 0
  fi

  echo "Retrieving secrets from 1Password..."

  for secret_def in "${secrets_list[@]}"; do
    local var_name="${secret_def%%:*}"
    local op_args_string="${secret_def#*:}"

    echo "  - Retrieving ${var_name}..."
    # Convert string to array for proper argument handling
    read -ra op_args <<< "$op_args_string"
    if ! secret_value=$(op --vault "$VAULT" "${op_args[@]}" 2>/dev/null); then
      echo "‚ùå Failed to retrieve ${var_name} from 1Password"
      exit 1
    fi

    if [[ -z "$secret_value" ]]; then
      echo "‚ùå Retrieved empty value for ${var_name} from 1Password"
      exit 1
    fi

    export "$var_name=$secret_value"
  done

  echo "‚úÖ Secrets retrieved successfully"
}

bootstrap_ansible() {
  local apply_mode="$1"
  local action_verb="$2"

  echo ""
  echo "${action_verb} Ansible vault password..."
  if [[ "$apply_mode" == "true" ]]; then
    echo "$ANSIBLE_VAULT_PASS" > ansible/ansible-vault-password
    echo "‚úÖ Updated ansible/ansible-vault-password"
  else
    CURRENT_VAULT_PASS=""
    if [[ -f "ansible/ansible-vault-password" ]]; then
      CURRENT_VAULT_PASS=$(cat ansible/ansible-vault-password)
    fi
    if [[ "$CURRENT_VAULT_PASS" != "$ANSIBLE_VAULT_PASS" ]]; then
      echo "üìù Would update ansible/ansible-vault-password"
    else
      echo "‚úÖ ansible/ansible-vault-password is up to date"
    fi
  fi
}

bootstrap_direnv() {
  local apply_mode="$1"
  local action_verb="$2"

  echo ""
  echo "${action_verb} direnv secrets..."

  # Verify age is installed (provided by nix flake)
  if ! command -v age >/dev/null 2>&1; then
    echo "‚ùå age CLI not found. Run 'nix develop' to enter the development environment."
    exit 1
  fi

  if [[ ! -f ".secrets.tmpl" ]]; then
    echo "‚ö†Ô∏è  .secrets.tmpl not found, skipping direnv secrets"
    return
  fi

  # Get age encryption key (public key) from 1Password
  local age_recipient
  if ! age_recipient=$(op read "op://infra/direnv-age-key/public_key" 2>&1); then
    echo "‚ùå Failed to read age public key from 1Password: $age_recipient"
    echo "   Ensure 'direnv-age-key' item exists in the 'infra' vault with a 'public_key' field"
    exit 1
  fi

  if [[ "$apply_mode" == "true" ]]; then
    # Inject secrets and encrypt with age
    if ! op inject -i .secrets.tmpl | age -r "$age_recipient" -o .secrets.age; then
      echo "‚ùå Failed to encrypt secrets. Check that .secrets.tmpl references are valid."
      exit 1
    fi
    # Store template hash for staleness detection
    sha256sum .secrets.tmpl | cut -d' ' -f1 > .secrets.tmpl.hash
    echo "‚úÖ Updated .secrets.age"
  else
    # Generate what the new file would look like and compare
    local temp_encrypted
    temp_encrypted=$(mktemp)
    if ! op inject -i .secrets.tmpl | age -r "$age_recipient" -o "$temp_encrypted"; then
      echo "‚ùå Failed to encrypt secrets. Check that .secrets.tmpl references are valid."
      rm -f "$temp_encrypted"
      exit 1
    fi

    if [[ -f ".secrets.age" ]]; then
      # Decrypt both and compare (can't compare encrypted files directly)
      local age_key
      if ! age_key=$(op read "op://infra/direnv-age-key/password" 2>&1); then
        echo "‚ùå Failed to read age private key from 1Password: $age_key"
        echo "   Ensure 'direnv-age-key' item exists in the 'infra' vault with a 'password' field"
        rm -f "$temp_encrypted"
        exit 1
      fi
      local current_decrypted new_decrypted
      current_decrypted=$(age -d -i <(echo "$age_key") .secrets.age 2>/dev/null || echo "")
      new_decrypted=$(age -d -i <(echo "$age_key") "$temp_encrypted" 2>/dev/null || echo "")

      if [[ "$current_decrypted" == "$new_decrypted" ]]; then
        echo "‚úÖ .secrets.age is up to date"
      else
        echo "üìù Would update .secrets.age:"
        diff -u <(echo "$current_decrypted") <(echo "$new_decrypted") || true
      fi
    else
      echo "üìù Would create .secrets.age"
    fi

    rm -f "$temp_encrypted"
  fi
}

bootstrap_esphome() {
  local apply_mode="$1"
  local action_verb="$2"

  echo ""
  echo "${action_verb} ESPHome secrets..."
  if [[ -f "esphome/secrets.tmpl" ]]; then
    if [[ "$apply_mode" == "true" ]]; then
      op inject -f -i esphome/secrets.tmpl -o esphome/secrets.yaml
      echo "‚úÖ Updated esphome/secrets.yaml"
    else
      # Generate what the new file would look like and compare
      TEMP_SECRETS=$(mktemp)
      rm -f "$TEMP_SECRETS"  # Remove it so op inject doesn't prompt to overwrite
      op inject -i esphome/secrets.tmpl -o "$TEMP_SECRETS" >/dev/null

      if [[ -f "esphome/secrets.yaml" ]]; then
        if diff -q esphome/secrets.yaml "$TEMP_SECRETS" >/dev/null 2>&1; then
          echo "‚úÖ esphome/secrets.yaml is up to date"
        else
          echo "üìù Would update esphome/secrets.yaml:"
          diff -u esphome/secrets.yaml "$TEMP_SECRETS" || true
        fi
      else
        echo "üìù Would create esphome/secrets.yaml:"
        echo "--- /dev/null"
        echo "+++ esphome/secrets.yaml"
        sed 's/^/+/' "$TEMP_SECRETS"
      fi

      rm -f "$TEMP_SECRETS"
    fi
  else
    echo "‚ö†Ô∏è  esphome/secrets.tmpl not found, skipping ESPHome secrets"
  fi
}

bootstrap_kubernetes() {
  local apply_mode="$1"
  local action_verb="$2"

  # Create namespaces
  echo ""
  echo "${action_verb} namespaces..."
  if [[ "$apply_mode" == "true" ]]; then
    cat <<EOF | kubectl apply -f -
---
apiVersion: v1
kind: Namespace
metadata:
  name: 1password
---
apiVersion: v1
kind: Namespace
metadata:
  name: external-secrets
EOF
  else
    DIFF_OUTPUT=$(cat <<EOF | kubectl diff -f - 2>/dev/null || true
---
apiVersion: v1
kind: Namespace
metadata:
  name: 1password
---
apiVersion: v1
kind: Namespace
metadata:
  name: external-secrets
EOF
)
    if [[ -z "$DIFF_OUTPUT" ]]; then
      echo "‚úÖ namespaces are up to date"
    else
      echo "üìù Would update namespaces:"
      echo "$DIFF_OUTPUT"
    fi
  fi

  # Generate and apply Kubernetes secrets
  echo ""
  OP_CREDENTIALS_B64=$(echo "$OP_CREDENTIALS" | base64)

  if [[ "$apply_mode" == "true" ]]; then
    echo "Creating 1password-connect credentials..."
    echo "$OP_CREDENTIALS_B64" | \
      kubectl create secret generic op-credentials \
      --namespace=1password \
      --from-file=1password-credentials.json=/dev/stdin \
      --dry-run=client -o yaml | \
      kubectl apply -f -

    echo "Creating external-secrets token..."
    kubectl create secret generic secrets \
      --namespace=external-secrets \
      --from-literal=token="$EXTERNAL_SECRETS_TOKEN" \
      --dry-run=client -o yaml | \
      kubectl apply -f -
  else
    echo "Checking 1password-connect credentials..."
    echo "$OP_CREDENTIALS_B64" | \
      kubectl create secret generic op-credentials \
      --namespace=1password \
      --from-file=1password-credentials.json=/dev/stdin \
      --dry-run=client -o yaml | \
      kubectl diff -f - || true

    echo "Checking external-secrets token..."
    kubectl create secret generic secrets \
      --namespace=external-secrets \
      --from-literal=token="$EXTERNAL_SECRETS_TOKEN" \
      --dry-run=client -o yaml | \
      kubectl diff -f - || true
  fi
}

# Parse arguments
APPLY_MODE=false
TARGETS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --apply)
      APPLY_MODE=true
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    ansible|direnv|esphome|kubernetes)
      TARGETS+=("$1")
      shift
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

# Default to all targets if none specified
if [[ ${#TARGETS[@]} -eq 0 ]]; then
  TARGETS=(ansible direnv esphome kubernetes)
fi

if [[ "$APPLY_MODE" == "true" ]]; then
  ACTION_VERB="Updating"
  echo "üöÄ Deploying bootstrap secrets: ${TARGETS[*]}"
else
  ACTION_VERB="Checking"
  echo "üîç Diff mode: showing what would change for: ${TARGETS[*]}"
fi

# Retrieve only the secrets we need
get_secrets "${TARGETS[@]}"

# Run selected targets
for target in "${TARGETS[@]}"; do
  case "$target" in
    ansible)
      bootstrap_ansible "$APPLY_MODE" "$ACTION_VERB"
      ;;
    direnv)
      bootstrap_direnv "$APPLY_MODE" "$ACTION_VERB"
      ;;
    esphome)
      bootstrap_esphome "$APPLY_MODE" "$ACTION_VERB"
      ;;
    kubernetes)
      bootstrap_kubernetes "$APPLY_MODE" "$ACTION_VERB"
      ;;
  esac
done

echo ""
if [[ "$APPLY_MODE" == "true" ]]; then
  echo "‚úÖ Bootstrap complete!"
else
  echo "‚úÖ Diff complete!"
  echo ""
  echo "üìã To apply changes, run:"
  echo "  ./scripts/bootstrap-secrets --apply ${TARGETS[*]}"
fi
