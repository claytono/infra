#!/bin/bash

set -eu -o pipefail

BASEDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$BASEDIR")"
VAULT="infra"

cd "$REPO_ROOT"

# Retrieve and validate all required secrets from 1Password
get_secrets() {
  local secrets_list=(
    "ANSIBLE_VAULT_PASS:item get ansible-vault-password --fields password"
    "OP_CREDENTIALS:document get 1password-credentials.json"
    "EXTERNAL_SECRETS_TOKEN:document get external-secrets-token"
  )

  echo "Retrieving all secrets from 1Password..."

  for secret_def in "${secrets_list[@]}"; do
    local var_name="${secret_def%%:*}"
    local op_args_string="${secret_def#*:}"

    echo "  - Retrieving ${var_name}..."
    # Convert string to array for proper argument handling
    read -ra op_args <<< "$op_args_string"
    if ! secret_value=$(op --vault "$VAULT" "${op_args[@]}" 2>/dev/null); then
      echo "‚ùå Failed to retrieve ${var_name} from 1Password"
      exit 1
    fi

    if [[ -z "$secret_value" ]]; then
      echo "‚ùå Retrieved empty value for ${var_name} from 1Password"
      exit 1
    fi

    export "$var_name=$secret_value"
  done

  echo "‚úÖ All secrets retrieved successfully"
}

# Parse arguments
APPLY_MODE=false
if [[ "${1:-}" == "--apply" ]]; then
  APPLY_MODE=true
  ACTION_VERB="Updating"
  echo "üöÄ Deploying bootstrap secrets..."
else
  ACTION_VERB="Checking"
  echo "üîç Diff mode: showing what would change..."
fi

# Retrieve all secrets upfront
get_secrets

# 1. Update Ansible vault password
echo ""
echo "${ACTION_VERB} Ansible vault password..."
if [[ "$APPLY_MODE" == "true" ]]; then
  echo "$ANSIBLE_VAULT_PASS" > ansible/ansible-vault-password
  echo "‚úÖ Updated ansible/ansible-vault-password"
else
  CURRENT_VAULT_PASS=""
  if [[ -f "ansible/ansible-vault-password" ]]; then
    CURRENT_VAULT_PASS=$(cat ansible/ansible-vault-password)
  fi
  if [[ "$CURRENT_VAULT_PASS" != "$ANSIBLE_VAULT_PASS" ]]; then
    echo "üìù Would update ansible/ansible-vault-password"
  else
    echo "‚úÖ ansible/ansible-vault-password is up to date"
  fi
fi

# 2. Update ESPHome secrets
echo ""
echo "${ACTION_VERB} ESPHome secrets..."
if [[ -f "esphome/secrets.tmpl" ]]; then
  if [[ "$APPLY_MODE" == "true" ]]; then
    op inject -i esphome/secrets.tmpl -o esphome/secrets.yaml
    echo "‚úÖ Updated esphome/secrets.yaml"
  else
    # Generate what the new file would look like and compare
    TEMP_SECRETS=$(mktemp)
    rm -f "$TEMP_SECRETS"  # Remove it so op inject doesn't prompt to overwrite
    op inject -i esphome/secrets.tmpl -o "$TEMP_SECRETS" >/dev/null

    if [[ -f "esphome/secrets.yaml" ]]; then
      if diff -q esphome/secrets.yaml "$TEMP_SECRETS" >/dev/null 2>&1; then
        echo "‚úÖ esphome/secrets.yaml is up to date"
      else
        echo "üìù Would update esphome/secrets.yaml:"
        diff -u esphome/secrets.yaml "$TEMP_SECRETS" || true
      fi
    else
      echo "üìù Would create esphome/secrets.yaml:"
      echo "--- /dev/null"
      echo "+++ esphome/secrets.yaml"
      sed 's/^/+/' "$TEMP_SECRETS"
    fi

    rm -f "$TEMP_SECRETS"
  fi
else
  echo "‚ö†Ô∏è  esphome/secrets.tmpl not found, skipping ESPHome secrets"
fi

# 3. Create namespaces
echo ""
echo "${ACTION_VERB} namespaces..."
if [[ "$APPLY_MODE" == "true" ]]; then
  cat <<EOF | kubectl apply -f -
---
apiVersion: v1
kind: Namespace
metadata:
  name: 1password
---
apiVersion: v1
kind: Namespace
metadata:
  name: external-secrets
EOF
else
  DIFF_OUTPUT=$(cat <<EOF | kubectl diff -f - 2>/dev/null || true
---
apiVersion: v1
kind: Namespace
metadata:
  name: 1password
---
apiVersion: v1
kind: Namespace
metadata:
  name: external-secrets
EOF
)
  if [[ -z "$DIFF_OUTPUT" ]]; then
    echo "‚úÖ namespaces are up to date"
  else
    echo "üìù Would update namespaces:"
    echo "$DIFF_OUTPUT"
  fi
fi

echo ""

# 4. Generate and apply Kubernetes secrets
echo ""
OP_CREDENTIALS_B64=$(echo "$OP_CREDENTIALS" | base64)

if [[ "$APPLY_MODE" == "true" ]]; then
  echo "Creating 1password-connect credentials..."
  echo "$OP_CREDENTIALS_B64" | \
    kubectl create secret generic op-credentials \
    --namespace=1password \
    --from-file=1password-credentials.json=/dev/stdin \
    --dry-run=client -o yaml | \
    kubectl apply -f -

  echo "Creating external-secrets token..."
  kubectl create secret generic secrets \
    --namespace=external-secrets \
    --from-literal=token="$EXTERNAL_SECRETS_TOKEN" \
    --dry-run=client -o yaml | \
    kubectl apply -f -
else
  echo "Checking 1password-connect credentials..."
  echo "$OP_CREDENTIALS_B64" | \
    kubectl create secret generic op-credentials \
    --namespace=1password \
    --from-file=1password-credentials.json=/dev/stdin \
    --dry-run=client -o yaml | \
    kubectl diff -f - || true

  echo "Checking external-secrets token..."
  kubectl create secret generic secrets \
    --namespace=external-secrets \
    --from-literal=token="$EXTERNAL_SECRETS_TOKEN" \
    --dry-run=client -o yaml | \
    kubectl diff -f - || true
fi

if [[ "$APPLY_MODE" == "true" ]]; then
  echo "‚úÖ Bootstrap secrets deployed successfully!"
  echo ""
  echo "üìã Summary:"
  echo "  - Ansible: ansible/ansible-vault-password"
  echo "  - ESPHome: esphome/secrets.yaml"
  echo "  - Namespace: 1password"
  echo "    - Secret: op-credentials"
  echo "  - Namespace: external-secrets"
  echo "    - Secret: secrets"
  echo ""
  echo "üéØ Services can now be deployed via ArgoCD"
else
  echo "‚úÖ Diff complete!"
  echo ""
  echo "üìã To apply changes, run:"
  echo "  ./scripts/bootstrap-secrets --apply"
fi
