#!/usr/bin/env python3
"""Generate flake-versions.yaml from the current flake.lock.

Default mode: regenerates flake-versions.yaml. If versions changed and
--comment-file is given, writes a markdown diff table to that file.

--check mode: compares without writing, exits non-zero if stale.
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent
OUTPUT = REPO_ROOT / "flake-versions.yaml"
HEADER = "---\n# Auto-generated from flake.lock â€” do not edit\n# Regenerate with: scripts/gen-flake-versions\n"


def get_system() -> str:
    result = subprocess.run(
        ["nix", "eval", "--impure", "--raw", "--expr", "builtins.currentSystem"],
        capture_output=True,
        text=True,
        check=True,
        cwd=REPO_ROOT,
    )
    return result.stdout.strip()


def get_versions(system: str) -> dict[str, str]:
    nix_apply = """ps: map (p: {
        name = p.pname or (builtins.parseDrvName p.name).name;
        version = p.version or (builtins.parseDrvName p.name).version;
    }) ps"""

    result = subprocess.run(
        [
            "nix",
            "eval",
            "--json",
            f".#devShells.{system}.default.nativeBuildInputs",
            "--apply",
            nix_apply,
        ],
        capture_output=True,
        text=True,
        check=True,
        cwd=REPO_ROOT,
    )

    packages = json.loads(result.stdout)
    return {
        p["name"]: p["version"]
        for p in sorted(packages, key=lambda p: p["name"])
        if p["version"]
    }


def render_yaml(versions: dict[str, str]) -> str:
    lines = [HEADER]
    for name, version in versions.items():
        lines.append(f"{name}: {version}")
    lines.append("")  # trailing newline
    return "\n".join(lines)


def parse_yaml(content: str) -> dict[str, str]:
    versions = {}
    for line in content.splitlines():
        if line.startswith("#") or line.startswith("---") or not line.strip():
            continue
        name, _, value = line.partition(": ")
        versions[name] = value.strip('"')
    return versions


def diff_table(old: dict[str, str], new: dict[str, str]) -> str:
    all_names = sorted(set(old) | set(new))
    rows = []
    for name in all_names:
        old_v = old.get(name, "")
        new_v = new.get(name, "")
        if old_v != new_v:
            rows.append(f"| {name} | {old_v} | {new_v} |")

    if not rows:
        return ""

    lines = [
        "### Package version changes",
        "",
        "| Package | Old | New |",
        "|---------|-----|-----|",
        *rows,
    ]
    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if flake-versions.yaml is up to date (no write)",
    )
    parser.add_argument(
        "--comment-file",
        type=Path,
        help="Write markdown diff table to this file (if versions changed)",
    )
    args = parser.parse_args()

    system = get_system()
    versions = get_versions(system)
    new_content = render_yaml(versions)

    if args.check:
        if OUTPUT.exists() and OUTPUT.read_text() == new_content:
            sys.exit(0)
        print(
            "flake-versions.yaml is out of date. "
            "Regenerate with: scripts/gen-flake-versions",
            file=sys.stderr,
        )
        sys.exit(1)

    # Diff against existing file
    if OUTPUT.exists():
        old_content = OUTPUT.read_text()
        if old_content == new_content:
            sys.exit(0)
        old_versions = parse_yaml(old_content)
        table = diff_table(old_versions, versions)
        if table and args.comment_file:
            args.comment_file.write_text(table + "\n")

    OUTPUT.write_text(new_content)


if __name__ == "__main__":
    main()
